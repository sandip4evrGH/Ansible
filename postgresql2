Okay, here is all the consolidated Ansible code, including the directory structure, inventory, playbooks, and role files, incorporating all the updates and clarifications we've discussed: EFS-mounted binaries, role-based logic with target_role extra-var, and general management tasks.
Directory Structure
.
├── inventory.ini
├── playbook.yml            # Main playbook to call roles
└── roles/
    ├── postgresql_install/
    │   ├── tasks/
    │   │   ├── main.yml             # Common install & base config for all PG hosts
    │   │   ├── configure_primary.yml  # Primary-specific setup (initdb, users, dbs)
    │   │   └── configure_replica.yml  # Replica-specific setup (pg_basebackup, standby.signal)
    │   ├── templates/
    │   │   ├── pg_hba.conf.j2
    │   │   ├── postgresql.conf.j2
    │   │   └── pgpass.j2              # For pg_basebackup authentication
    │   ├── handlers/
    │   │   └── main.yml
    │   └── vars/
    │       └── main.yml
    └── postgresql_manage/
        ├── tasks/
        │   ├── main.yml             # Start/Stop/Reload/Status tasks
        │   ├── backup.yml           # For logical backups (pg_dumpall) or re-initiating replica
        │   └── failover.yml         # Placeholder for failover logic
        ├── handlers/
        │   └── main.yml
        └── vars/
            └── main.yml

File Contents
inventory.ini
# inventory.ini
[postgresql]
Apphost1 role=primary
Apphost2 role=replica

playbook.yml
---
- name: PostgreSQL Installation and Management
  hosts: postgresql # Targets both Apphost1 and Apphost2 from your inventory
  become: yes

  # The 'target_role' variable will be passed via --extra-vars when running the playbook.
  # Example: ansible-playbook playbook.yml --extra-vars "target_role=primary"

  roles:
    # This role handles initial setup, ensuring binaries are recognized,
    # and configuring primary/replica specific aspects.
    - role: postgresql_install
      tags:
        - install
        - setup
        - primary_setup
        - replica_setup

    # This role handles ongoing management tasks like start/stop/reload,
    # backups, and potential failover operations.
    - role: postgresql_manage
      tags:
        - manage
        - control
        - backup
        - failover

roles/postgresql_install/vars/main.yml
# roles/postgresql_install/vars/main.yml
pg_data_dir: "/data/local/arcol/airflow/pgdata"
pg_install_dir: "/efs/dist/postgresql/core/14.10" # Path to EFS mounted PostgreSQL binaries
database_name: "airflowdb"
replication_user: "replication_user"
airflow_user: "airflow_user"

# Template paths relative to the role's templates/ directory
pg_hba_conf_template: "pg_hba.conf.j2"
postgresql_conf_template: "postgresql.conf.j2"
pgpass_template: "pgpass.j2" # For pg_basebackup authentication

# Action variable to control what tasks are run within this role (e.g., 'base_install', 'configure_primary', 'configure_replica')
install_action: "base_install"

# Variable to define which role to target for actions (e.g., 'primary', 'replica', or 'all' for both)
# Default to 'all' meaning tasks will run based on host's inventory 'role' if target_role is not specified.
target_role: "all"

# PostgreSQL service name (adjust for your OS/version and EFS setup's systemd integration)
pg_service_name: postgresql-14

# These should be retrieved securely (e.g., from Ansible Vault or HashiCorp Vault)
# Make sure your Ansible environment is configured to retrieve these secrets.
pg_replication_pwd: "{{ lookup('ansible.builtin.hashi_vault', 'secret=field-pg_replication_pwd_devops:value') }}"
pg_airflow_pwd: "{{ lookup('ansible.builtin.hashi_vault', 'secret=field-pg_airflow_pwd_devops:value') }}"

roles/postgresql_install/tasks/main.yml
# roles/postgresql_install/tasks/main.yml
# This file assumes PostgreSQL binaries are directly available from a mounted EFS share.
# The EFS share must be mounted at {{ pg_install_dir }} before this playbook runs.

- name: Ensure PostgreSQL installation directory exists (on EFS share)
  ansible.builtin.file:
    path: "{{ pg_install_dir }}"
    state: directory
    # owner: postgres # Optional: if the EFS mount point needs a specific owner
    # group: postgres # Optional
    # mode: '0755'    # Optional: adjust permissions as needed for the EFS mount point
  # This task confirms the mount point for your EFS share is present.
  # It does NOT mount EFS; it assumes it's already mounted by system provisioning.

- name: Ensure PostgreSQL data directory exists (on local disk, or separate EFS if configured)
  ansible.builtin.file:
    path: "{{ pg_data_dir }}"
    state: directory
    owner: postgres
    group: postgres
    mode: '0700'
  # Note: pg_data_dir is typically on a local disk or a separate, dedicated storage (e.g., EBS volume, another EFS volume).
  # It's generally not recommended to place pg_data_dir directly on the same shared EFS as binaries due to performance or consistency issues.

- name: Ensure postgresql service is enabled
  ansible.builtin.systemd:
    name: "{{ pg_service_name }}"
    enabled: yes
  # This assumes your "EFS-based" installation has a systemd service unit configured
  # (e.g., placed in /etc/systemd/system by some other process or manually).

- name: Copy postgresql.conf from template
  ansible.builtin.template:
    src: "{{ postgresql_conf_template }}"
    dest: "{{ pg_data_dir }}/postgresql.conf"
    owner: postgres
    group: postgres
    mode: '0600'
  notify: Reload PostgreSQL

- name: Copy pg_hba.conf from template
  ansible.builtin.template:
    src: "{{ pg_hba_conf_template }}"
    dest: "{{ pg_data_dir }}/pg_hba.conf"
    owner: postgres
    group: postgres
    mode: '0600'
  notify: Reload PostgreSQL

# Include primary/replica specific configuration tasks based on host's role AND target_role
- name: Include primary configuration tasks
  ansible.builtin.include_tasks: configure_primary.yml
  when: role == 'primary' and (target_role == 'all' or target_role == 'primary') and install_action in ['base_install', 'configure_primary']

- name: Include replica configuration tasks
  ansible.builtin.include_tasks: configure_replica.yml
  when: role == 'replica' and (target_role == 'all' or target_role == 'replica') and install_action in ['base_install', 'configure_replica']

roles/postgresql_install/tasks/configure_primary.yml
# roles/postgresql_install/tasks/configure_primary.yml
# These tasks run only on hosts where inventory 'role' is 'primary' and 'target_role' matches.

- name: Initialize PostgreSQL primary cluster if not already present
  community.general.postgresql_cluster:
    name: main
    cluster_owner: postgres
    data_directory: "{{ pg_data_dir }}"
    port: 5432
    state: present
  become_user: postgres

- name: Start PostgreSQL primary database
  ansible.builtin.systemd:
    name: "{{ pg_service_name }}"
    state: started

- name: Create PostgreSQL database {{ database_name }}
  community.general.postgresql_db:
    name: "{{ database_name }}"
    owner: "{{ airflow_user }}"
    encoding: "UTF8"
    lc_collate: "en_US.UTF-8"
    lc_ctype: "en_US.UTF-8"
    state: present
  become_user: postgres

- name: Create replication user {{ replication_user }}
  community.general.postgresql_user:
    name: "{{ replication_user }}"
    password: "{{ pg_replication_pwd }}"
    role_attr_flags: REPLICATION,LOGIN
    state: present
  become_user: postgres

- name: Grant all privileges on database to replication user
  community.general.postgresql_privs:
    db: "{{ database_name }}"
    privs: ALL
    type: database
    roles: "{{ replication_user }}"
    state: present
  become_user: postgres

- name: Create Airflow user {{ airflow_user }}
  community.general.postgresql_user:
    name: "{{ airflow_user }}"
    password: "{{ pg_airflow_pwd }}"
    role_attr_flags: LOGIN,PASSWORD
    state: present
  become_user: postgres

- name: Grant all privileges on database to Airflow user
  community.general.postgresql_privs:
    db: "{{ database_name }}"
    privs: ALL
    type: database
    roles: "{{ airflow_user }}"
    state: present
  become_user: postgres

roles/postgresql_install/tasks/configure_replica.yml
# roles/postgresql_install/tasks/configure_replica.yml
# These tasks run only on hosts where inventory 'role' is 'replica' and 'target_role' matches.

- name: Ensure PostgreSQL data directory on replica is clean or empty for base backup
  ansible.builtin.file:
    path: "{{ pg_data_dir }}"
    state: absent
  # CRITICAL: ONLY run this if you are absolutely sure you want to re-initialize a fresh replica.
  # This will wipe existing data in pg_data_dir before performing a new base backup.

- name: Recreate PostgreSQL data directory on replica
  ansible.builtin.file:
    path: "{{ pg_data_dir }}"
    state: directory
    owner: postgres
    group: postgres
    mode: '0700'

- name: Create .pgpass file for passwordless authentication on replica
  ansible.builtin.template:
    src: "{{ pgpass_template }}"
    dest: "~postgres/.pgpass"
    owner: postgres
    group: postgres
    mode: '0600'
  become_user: postgres

- name: Perform pg_basebackup from primary to replica
  # primary_db_address should be defined in playbook.yml or vars/main.yml
  ansible.builtin.command: >
    {{ pg_install_dir }}/bin/pg_basebackup -h {{ primary_db_address }}
    -p 5432 -U {{ replication_user }}
    -X stream -C -D {{ pg_data_dir }} -w
  become_user: postgres
  environment:
    PGDATA: "{{ pg_data_dir }}"
  args:
    creates: "{{ pg_data_dir }}/basebackup.complete" # Make idempotent by checking for a marker file

- name: Create marker file after successful base backup
  ansible.builtin.file:
    path: "{{ pg_data_dir }}/basebackup.complete"
    state: touch
    owner: postgres
    group: postgres
    mode: '0600'
  when: not ansible_check_mode # Don't create marker during check mode

- name: Create standby.signal file for replica (PostgreSQL 12+)
  ansible.builtin.file:
    path: "{{ pg_data_dir }}/standby.signal"
    state: touch
    owner: postgres
    group: postgres
    mode: '0600'
  # pg_basebackup -C should typically create this, but explicitly ensuring it.

- name: Configure primary_conninfo in postgresql.conf for replica
  ansible.builtin.lineinfile:
    path: "{{ pg_data_dir }}/postgresql.conf"
    regexp: '^#?primary_conninfo =.*'
    line: "primary_conninfo = 'host={{ primary_db_address }} port=5432 user={{ replication_user }} password={{ pg_replication_pwd }}'"
    backup: yes
    owner: postgres
    group: postgres
    mode: '0600'
  notify: Restart PostgreSQL # Restart is usually needed for primary_conninfo changes

- name: Start PostgreSQL replica database
  ansible.builtin.systemd:
    name: "{{ pg_service_name }}"
    state: started

roles/postgresql_install/templates/pg_hba.conf.j2
# roles/postgresql_install/templates/pg_hba.conf.j2
# TYPE  DATABASE        USER            ADDRESS                 METHOD

# "local" is for Unix domain socket connections only
local   all             all                                     peer
# IPv4 local connections:
host    all             all             127.0.0.1/32            scram-sha-256
# IPv6 local connections:
host    all             all             ::1/128                 scram-sha-256
# Allow replication connections from primary (e.g., {{ primary_db_address }})
host    replication     {{ replication_user }} {{ primary_db_address }}/32 scram-sha-256
# Allow connections from other hosts as needed for airflow_user
host    all             {{ airflow_user }}      0.0.0.0/0               scram-sha-256
host    {{ database_name }}     {{ airflow_user }}      0.0.0.0/0               scram-sha-256

Note: Adjust 0.0.0.0/0 to specific IP ranges for security. primary_db_address is assumed to be defined in playbook.yml's vars or passed as extra-var.
roles/postgresql_install/templates/postgresql.conf.j2
# roles/postgresql_install/templates/postgresql.conf.j2
# (Example, include your standard settings)
data_directory = '{{ pg_data_dir }}'
listen_addresses = '*' # IMPORTANT: Only if you want to connect remotely
port = 5432

# Logging
log_destination = 'stderr'
logging_collector = on
log_directory = 'pg_log'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
log_min_duration_statement = 1000 # Log statements that take longer than 1 second

# WAL management for replication (primary specific)
{% if role == 'primary' %}
wal_level = replica
max_wal_senders = 10 # Adjust based on number of replicas + backup tools
max_replication_slots = 5 # Adjust based on number of replicas + backup tools
archive_mode = on
archive_command = 'cp %p /path/to/wal_archive/%f' # CONFIGURE YOUR WAL ARCHIVING PATH
{% endif %}

# Connection settings
max_connections = 100

# Other settings as needed for your environment

roles/postgresql_install/templates/pgpass.j2
# roles/postgresql_install/templates/pgpass.j2
# host:port:database:user:password
# This file is used by pg_basebackup on the replica to connect to the primary without password prompt.
{{ primary_db_address }}:5432:*:{{ replication_user }}:{{ pg_replication_pwd }}

roles/postgresql_install/handlers/main.yml
# roles/postgresql_install/handlers/main.yml
- name: Reload PostgreSQL
  ansible.builtin.systemd:
    name: "{{ pg_service_name }}"
    state: reloaded

- name: Restart PostgreSQL
  ansible.builtin.systemd:
    name: "{{ pg_service_name }}"
    state: restarted

roles/postgresql_manage/vars/main.yml
# roles/postgresql_manage/vars/main.yml
pg_service_name: postgresql-14 # Ensure consistency with install role
pg_data_dir: "/data/local/arcol/airflow/pgdata" # For status checks etc.

manage_action: "status" # Default action for management role (e.g., 'start', 'stop', 'backup')
target_role: "all"      # Default for target_role (e.g., 'primary', 'replica', 'all')

roles/postgresql_manage/tasks/main.yml
# roles/postgresql_manage/tasks/main.yml
- name: Start PostgreSQL database
  ansible.builtin.systemd:
    name: "{{ pg_service_name }}"
    state: started
  when: manage_action == "start" and (target_role == 'all' or role == target_role)

- name: Stop PostgreSQL database
  ansible.builtin.systemd:
    name: "{{ pg_service_name }}"
    state: stopped
  when: manage_action == "stop" and (target_role == 'all' or role == target_role)

- name: Reload PostgreSQL database configuration
  ansible.builtin.systemd:
    name: "{{ pg_service_name }}"
    state: reloaded
  when: manage_action == "reload" and (target_role == 'all' or role == target_role)

- name: Check PostgreSQL database status
  ansible.builtin.command: "{{ pg_install_dir }}/bin/pg_ctl -D {{ pg_data_dir }} status" # Use full path from EFS
  register: pg_status_output
  changed_when: false
  when: manage_action == "status" and (target_role == 'all' or role == target_role)

- name: Print PostgreSQL status
  ansible.builtin.debug:
    var: pg_status_output.stdout_lines
  when: manage_action == "status" and (target_role == 'all' or role == target_role)

# Include other management tasks based on action and target_role
- name: Include backup tasks
  ansible.builtin.include_tasks: backup.yml
  when: manage_action == "backup" and (target_role == 'all' or role == target_role)
    # The backup.yml itself will likely have an internal check for 'role == primary'
    # so target_role='replica' and manage_action='backup' would lead to no action if backup.yml is primary-specific.

- name: Include failover tasks
  ansible.builtin.include_tasks: failover.yml
  when: manage_action == "failover" and (target_role == 'all' or role == target_role)

roles/postgresql_manage/tasks/backup.yml
# roles/postgresql_manage/tasks/backup.yml
# This task would typically run on the primary or a dedicated backup server.
- name: Ensure backup directory exists
  ansible.builtin.file:
    path: "/var/backups/postgresql_logical"
    state: directory
    owner: postgres
    group: postgres
    mode: '0700'
  when: role == 'primary' # This task specifically runs only on the primary instance.

- name: Perform pg_dumpall (logical backup)
  ansible.builtin.command: >
    {{ pg_install_dir }}/bin/pg_dumpall -U postgres > /var/backups/postgresql_logical/all_databases-{{ ansible_date_time.iso8601_basic }}.sql
  become_user: postgres
  when: role == 'primary'
  args:
    creates: "/var/backups/postgresql_logical/all_databases-{{ ansible_date_time.iso8601_basic }}.sql" # Simple idempotency

roles/postgresql_manage/tasks/failover.yml
# roles/postgresql_manage/tasks/failover.yml
- name: Failover Placeholder - Stop primary and promote replica
  ansible.builtin.debug:
    msg: "Failover logic would go here: stop current primary, promote replica, reconfigure old primary as new replica."
  when: false # This task won't run unless explicitly enabled and conditions met for failover

roles/postgresql_manage/handlers/main.yml
# roles/postgresql_manage/handlers/main.yml
# Handlers for postgresql_manage role (can reuse from install role or define separately)
- name: Reload PostgreSQL (manage)
  ansible.builtin.systemd:
    name: "{{ pg_service_name }}"
    state: reloaded

- name: Restart PostgreSQL (manage)
  ansible.builtin.systemd:
    name: "{{ pg_service_name }}"
    state: restarted

