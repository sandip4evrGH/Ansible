Okay, let's combine the postgresql_install and postgresql_manage roles into a single, comprehensive postgresql role. This makes your Ansible project more concise for managing a single application like PostgreSQL.
Updated Directory Structure
.
├── inventory.ini
├── playbook.yml            # Main playbook to call the single role
└── roles/
    └── postgresql/         # Combined PostgreSQL role
        ├── tasks/
        │   └── main.yml      # All PostgreSQL tasks
        ├── templates/
        │   ├── pg_hba.conf.j2
        │   ├── postgresql.conf.j2
        │   └── pgpass.j2
        ├── handlers/
        │   └── main.yml
        └── vars/
            └── main.yml

Consolidated File Contents
inventory.ini (No Change)
# inventory.ini
[postgresql]
Apphost1 role=primary
Apphost2 role=replica

playbook.yml (Simplified Entry Point)
---
- name: PostgreSQL Installation and Management
  hosts: postgresql # Targets both Apphost1 and Apphost2 from your inventory
  become: yes

  # Define common variables here if you prefer, or pass them via --extra-vars
  # primary_db_address: "Apphost1" # Example: if you need to define primary address outside role vars

  roles:
    # Call the single combined PostgreSQL role
    - role: postgresql
      # Tags can still be used to filter specific parts of the combined role if desired
      tags:
        - postgresql_management

roles/postgresql/vars/main.yml (Combined Variables)
# roles/postgresql/vars/main.yml
pg_data_dir: "/data/local/arcol/airflow/pgdata"
pg_install_dir: "/efs/dist/postgresql/core/14.10" # Path to EFS mounted PostgreSQL binaries
database_name: "airflowdb"
replication_user: "replication_user"
airflow_user: "airflow_user"

# Template paths relative to the role's templates/ directory
pg_hba_conf_template: "pg_hba.conf.j2"
postgresql_conf_template: "postgresql.conf.j2"
pgpass_template: "pgpass.j2"

# Main action variable to control what tasks are run within this role
# Default to 'status', user can override with --extra-vars "pg_action=install_base" etc.
pg_action: "status"

# Variable to define which role to target for actions (e.g., 'primary', 'replica', or 'all' for both)
# Default to 'all' meaning tasks will run based on host's inventory 'role' if target_role is not specified.
target_role: "all"

# PostgreSQL service name (adjust for your OS/version and EFS setup's systemd integration)
pg_service_name: postgresql-14

# These should be retrieved securely (e.g., from Ansible Vault or HashiCorp Vault)
# Make sure your Ansible environment is configured to retrieve these secrets.
pg_replication_pwd: "{{ lookup('ansible.builtin.hashi_vault', 'secret=field-pg_replication_pwd_devops:value') }}"
pg_airflow_pwd: "{{ lookup('ansible.builtin.hashi_vault', 'secret=field-pg_airflow_pwd_devops:value') }}"

# Define primary_db_address here if it's dynamic, or set a static value.
# Used for replica configuration and pg_hba.conf templates.
primary_db_address: "Apphost1" # Example: Assumes Apphost1 is always the primary

roles/postgresql/tasks/main.yml (All Combined Tasks)
This file will now contain all installation, configuration, and management tasks. The pg_action variable will control the flow.
# roles/postgresql/tasks/main.yml
# All PostgreSQL related tasks are combined here.
# Execution is controlled by 'pg_action' and 'target_role' variables.

# --- Common Installation & Base Configuration (pg_action: 'install_base') ---
- name: Ensure PostgreSQL installation directory exists (on EFS share)
  ansible.builtin.file:
    path: "{{ pg_install_dir }}"
    state: directory
  when: pg_action == 'install_base'

- name: Ensure PostgreSQL data directory exists
  ansible.builtin.file:
    path: "{{ pg_data_dir }}"
    state: directory
    owner: postgres
    group: postgres
    mode: '0700'
  when: pg_action == 'install_base' or pg_action == 'configure_replica' # Replica needs data dir for base backup

- name: Ensure postgresql service is enabled
  ansible.builtin.systemd:
    name: "{{ pg_service_name }}"
    enabled: yes
  when: pg_action == 'install_base'

- name: Copy postgresql.conf from template
  ansible.builtin.template:
    src: "{{ postgresql_conf_template }}"
    dest: "{{ pg_data_dir }}/postgresql.conf"
    owner: postgres
    group: postgres
    mode: '0600'
  notify: Reload PostgreSQL
  when: pg_action == 'install_base'

- name: Copy pg_hba.conf from template
  ansible.builtin.template:
    src: "{{ pg_hba_conf_template }}"
    dest: "{{ pg_data_dir }}/pg_hba.conf"
    owner: postgres
    group: postgres
    mode: '0600'
  notify: Reload PostgreSQL
  when: pg_action == 'install_base'

# --- Primary-Specific Configuration (pg_action: 'configure_primary') ---
- name: Initialize PostgreSQL primary cluster if not already present
  community.general.postgresql_cluster:
    name: main
    cluster_owner: postgres
    data_directory: "{{ pg_data_dir }}"
    port: 5432
    state: present
  become_user: postgres
  when: pg_action == 'configure_primary' and role == 'primary' and (target_role == 'all' or target_role == 'primary')

- name: Create PostgreSQL database {{ database_name }} (Primary)
  community.general.postgresql_db:
    name: "{{ database_name }}"
    owner: "{{ airflow_user }}"
    encoding: "UTF8"
    lc_collate: "en_US.UTF-8"
    lc_ctype: "en_US.UTF-8"
    state: present
  become_user: postgres
  when: pg_action == 'configure_primary' and role == 'primary' and (target_role == 'all' or target_role == 'primary')

- name: Create replication user {{ replication_user }} (Primary)
  community.general.postgresql_user:
    name: "{{ replication_user }}"
    password: "{{ pg_replication_pwd }}"
    role_attr_flags: REPLICATION,LOGIN
    state: present
  become_user: postgres
  when: pg_action == 'configure_primary' and role == 'primary' and (target_role == 'all' or target_role == 'primary')

- name: Grant all privileges on database to replication user (Primary)
  community.general.postgresql_privs:
    db: "{{ database_name }}"
    privs: ALL
    type: database
    roles: "{{ replication_user }}"
    state: present
  become_user: postgres
  when: pg_action == 'configure_primary' and role == 'primary' and (target_role == 'all' or target_role == 'primary')

- name: Create Airflow user {{ airflow_user }} (Primary)
  community.general.postgresql_user:
    name: "{{ airflow_user }}"
    password: "{{ pg_airflow_pwd }}"
    role_attr_flags: LOGIN,PASSWORD
    state: present
  become_user: postgres
  when: pg_action == 'configure_primary' and role == 'primary' and (target_role == 'all' or target_role == 'primary')

- name: Grant all privileges on database to Airflow user (Primary)
  community.general.postgresql_privs:
    db: "{{ database_name }}"
    privs: ALL
    type: database
    roles: "{{ airflow_user }}"
    state: present
  become_user: postgres
  when: pg_action == 'configure_primary' and role == 'primary' and (target_role == 'all' or target_role == 'primary')

# --- Replica-Specific Configuration (pg_action: 'configure_replica') ---
- name: Ensure PostgreSQL data directory on replica is clean or empty for base backup
  ansible.builtin.file:
    path: "{{ pg_data_dir }}"
    state: absent
  when: pg_action == 'configure_replica' and role == 'replica' and (target_role == 'all' or target_role == 'replica')
  # CRITICAL: ONLY run this if you are absolutely sure you want to re-initialize a fresh replica.

- name: Recreate PostgreSQL data directory on replica
  ansible.builtin.file:
    path: "{{ pg_data_dir }}"
    state: directory
    owner: postgres
    group: postgres
    mode: '0700'
  when: pg_action == 'configure_replica' and role == 'replica' and (target_role == 'all' or target_role == 'replica')

- name: Create .pgpass file for passwordless authentication on replica
  ansible.builtin.template:
    src: "{{ pgpass_template }}"
    dest: "~postgres/.pgpass"
    owner: postgres
    group: postgres
    mode: '0600'
  become_user: postgres
  when: pg_action == 'configure_replica' and role == 'replica' and (target_role == 'all' or target_role == 'replica')

- name: Perform pg_basebackup from primary to replica
  ansible.builtin.command: >
    {{ pg_install_dir }}/bin/pg_basebackup -h {{ primary_db_address }}
    -p 5432 -U {{ replication_user }}
    -X stream -C -D {{ pg_data_dir }} -w
  become_user: postgres
  environment:
    PGDATA: "{{ pg_data_dir }}"
  args:
    creates: "{{ pg_data_dir }}/basebackup.complete"
  when: pg_action == 'configure_replica' and role == 'replica' and (target_role == 'all' or target_role == 'replica')

- name: Create marker file after successful base backup
  ansible.builtin.file:
    path: "{{ pg_data_dir }}/basebackup.complete"
    state: touch
    owner: postgres
    group: postgres
    mode: '0600'
  when: pg_action == 'configure_replica' and role == 'replica' and (target_role == 'all' or target_role == 'replica') and not ansible_check_mode

- name: Create standby.signal file for replica (PostgreSQL 12+)
  ansible.builtin.file:
    path: "{{ pg_data_dir }}/standby.signal"
    state: touch
    owner: postgres
    group: postgres
    mode: '0600'
  when: pg_action == 'configure_replica' and role == 'replica' and (target_role == 'all' or target_role == 'replica')

- name: Configure primary_conninfo in postgresql.conf for replica
  ansible.builtin.lineinfile:
    path: "{{ pg_data_dir }}/postgresql.conf"
    regexp: '^#?primary_conninfo =.*'
    line: "primary_conninfo = 'host={{ primary_db_address }} port=5432 user={{ replication_user }} password={{ pg_replication_pwd }}'"
    backup: yes
    owner: postgres
    group: postgres
    mode: '0600'
  notify: Restart PostgreSQL
  when: pg_action == 'configure_replica' and role == 'replica' and (target_role == 'all' or target_role == 'replica')

# --- General Management Actions (pg_action: 'start', 'stop', 'reload', 'status') ---
- name: Start PostgreSQL database
  ansible.builtin.systemd:
    name: "{{ pg_service_name }}"
    state: started
  when: pg_action == "start" and (target_role == 'all' or role == target_role)

- name: Stop PostgreSQL database
  ansible.builtin.systemd:
    name: "{{ pg_service_name }}"
    state: stopped
  when: pg_action == "stop" and (target_role == 'all' or role == target_role)

- name: Reload PostgreSQL database configuration
  ansible.builtin.systemd:
    name: "{{ pg_service_name }}"
    state: reloaded
  when: pg_action == "reload" and (target_role == 'all' or role == target_role)

- name: Check PostgreSQL database status
  ansible.builtin.command: "{{ pg_install_dir }}/bin/pg_ctl -D {{ pg_data_dir }} status"
  register: pg_status_output
  changed_when: false
  when: pg_action == "status" and (target_role == 'all' or role == target_role)

- name: Print PostgreSQL status
  ansible.builtin.debug:
    var: pg_status_output.stdout_lines
  when: pg_action == "status" and (target_role == 'all' or role == target_role)

# --- Backup Action (pg_action: 'backup') ---
- name: Perform Logical Backup (pg_dumpall)
  block:
    - name: Ensure backup directory exists
      ansible.builtin.file:
        path: "/var/backups/postgresql_logical"
        state: directory
        owner: postgres
        group: postgres
        mode: '0700'

    - name: Execute pg_dumpall
      ansible.builtin.command: >
        {{ pg_install_dir }}/bin/pg_dumpall -U postgres > /var/backups/postgresql_logical/all_databases-{{ ansible_date_time.iso8601_basic }}.sql
      become_user: postgres
      args:
        creates: "/var/backups/postgresql_logical/all_databases-{{ ansible_date_time.iso8601_basic }}.sql"
  when: pg_action == 'backup' and role == 'primary' and (target_role == 'all' or target_role == 'primary')

# --- Failover Action (pg_action: 'failover') ---
- name: Failover Placeholder - Stop primary and promote replica
  ansible.builtin.debug:
    msg: "Failover logic would go here: stop current primary, promote replica, reconfigure old primary as new replica."
  when: pg_action == 'failover' and (target_role == 'all' or role == target_role)
    # Failover logic is complex and needs careful consideration of roles.
    # This 'when' condition is a placeholder, actual failover would be more specific.


roles/postgresql/templates/pg_hba.conf.j2
# roles/postgresql/templates/pg_hba.conf.j2
# TYPE  DATABASE        USER            ADDRESS                 METHOD

# "local" is for Unix domain socket connections only
local   all             all                                     peer
# IPv4 local connections:
host    all             all             127.0.0.1/32            scram-sha-256
# IPv6 local connections:
host    all             all             ::1/128                 scram-sha-256
# Allow replication connections from primary (e.g., {{ primary_db_address }})
host    replication     {{ replication_user }} {{ primary_db_address }}/32 scram-sha-256
# Allow connections from other hosts as needed for airflow_user
host    all             {{ airflow_user }}      0.0.0.0/0               scram-sha-256
host    {{ database_name }}     {{ airflow_user }}      0.0.0.0/0               scram-sha-256

Note: Adjust 0.0.0.0/0 to specific IP ranges for security.
roles/postgresql/templates/postgresql.conf.j2
# roles/postgresql/templates/postgresql.conf.j2
# (Example, include your standard settings)
data_directory = '{{ pg_data_dir }}'
listen_addresses = '*' # IMPORTANT: Only if you want to connect remotely
port = 5432

# Logging
log_destination = 'stderr'
logging_collector = on
log_directory = 'pg_log'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
log_min_duration_statement = 1000 # Log statements that take longer than 1 second

# WAL management for replication (primary specific)
{% if role == 'primary' %}
wal_level = replica
max_wal_senders = 10 # Adjust based on number of replicas + backup tools
max_replication_slots = 5 # Adjust based on number of replicas + backup tools
archive_mode = on
archive_command = 'cp %p /path/to/wal_archive/%f' # CONFIGURE YOUR WAL ARCHIVING PATH
{% endif %}

# Connection settings
max_connections = 100

# Other settings as needed for your environment

roles/postgresql/templates/pgpass.j2
# roles/postgresql/templates/pgpass.j2
# host:port:database:user:password
# This file is used by pg_basebackup on the replica to connect to the primary without password prompt.
{{ primary_db_address }}:5432:*:{{ replication_user }}:{{ pg_replication_pwd }}

roles/postgresql/handlers/main.yml
# roles/postgresql/handlers/main.yml
- name: Reload PostgreSQL
  ansible.builtin.systemd:
    name: "{{ pg_service_name }}"
    state: reloaded

- name: Restart PostgreSQL
  ansible.builtin.systemd:
    name: "{{ pg_service_name }}"
    state: restarted

How to Run with the Combined Role
You will now always run the main playbook.yml, and use --extra-vars to control the pg_action and target_role.
Examples:
 * To perform basic installation and config file copy on ALL PostgreSQL hosts:
   ansible-playbook -i inventory.ini playbook.yml \
  --extra-vars "pg_action=install_base target_role=all" \
  --ask-vault-pass

 * To configure the Primary cluster (initdb, create dbs/users) on Apphost1 ONLY:
   ansible-playbook -i inventory.ini playbook.yml \
  --extra-vars "pg_action=configure_primary target_role=primary" \
  --ask-vault-pass

 * To configure the Replica (base backup, standby.signal) on Apphost2 ONLY:
   (Ensure primary is already running and configured for replication)
   ansible-playbook -i inventory.ini playbook.yml \
  --extra-vars "pg_action=configure_replica target_role=replica" \
  --ask-vault-pass

 * To start PostgreSQL service on ALL hosts:
   ansible-playbook -i inventory.ini playbook.yml \
  --extra-vars "pg_action=start target_role=all"

 * To check status of PostgreSQL service on the PRIMARY ONLY:
   ansible-playbook -i inventory.ini playbook.yml \
  --extra-vars "pg_action=status target_role=primary"

 * To perform a logical backup on the PRIMARY ONLY:
   ansible-playbook -i inventory.ini playbook.yml \
  --extra-vars "pg_action=backup target_role=primary"

This combined role simplifies your playbook structure while maintaining granular control through pg_action and target_role variables.
