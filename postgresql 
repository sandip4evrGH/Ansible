I can help you with a structured Ansible playbook to manage PostgreSQL primary and replica nodes.
Here's a breakdown of the components you'll need, followed by example playbook snippets. Please note that this is a comprehensive example and you'll need to adapt it to your specific environment (OS, PostgreSQL version, desired replication method like streaming replication, etc.).
Assumptions:
 * Operating System: RHEL/CentOS-based (adjust package names for Debian/Ubuntu).
 * PostgreSQL Version: 16 (adjust as needed).
 * Replication Method: Streaming Replication (most common and robust).
 * User: postgres user for PostgreSQL operations.
 * SSH Access: Ansible connects via SSH to your nodes.
 * Firewall: You'll need to open port 5432 on both nodes.
Inventory (inventory.ini):
[all:vars]
ansible_user=your_ssh_user
ansible_ssh_private_key_file=~/.ssh/id_rsa # Or use ssh-agent

[postgresql]
node1 ansible_host=your_primary_ip role=primary
node2 ansible_host=your_replica_ip role=replica

Directory Structure:
.
├── inventory.ini
├── playbook.yml
├── roles/
│   ├── postgresql_install/
│   │   ├── tasks/
│   │   │   └── main.yml
│   │   │   └── configure_primary.yml
│   │   │   └── configure_replica.yml
│   │   ├── templates/
│   │   │   └── pg_hba.conf.j2
│   │   │   └── postgresql.conf.j2
│   │   │   └── recovery.conf.j2  (for older versions, otherwise use primary_conninfo in postgresql.conf)
│   │   ├── handlers/
│   │   │   └── main.yml
│   │   └── vars/
│   │       └── main.yml
│   └── postgresql_manage/
│       ├── tasks/
│       │   └── main.yml
│       │   └── backup.yml
│       │   └── failover.yml
│       ├── handlers/
│       │   └── main.yml
│       └── vars/
│           └── main.yml

Playbook (playbook.yml):
This will orchestrate the roles.
---
- name: Install and Configure PostgreSQL Primary and Replica
  hosts: postgresql
  become: yes # Run tasks with sudo
  gather_facts: yes # Gather system facts for conditional logic

  roles:
    - role: postgresql_install

- name: Manage PostgreSQL Services
  hosts: postgresql
  become: yes

  tasks:
    # Example tasks for starting/stopping/reloading (can be part of postgresql_manage role)
    - name: Start PostgreSQL service
      ansible.builtin.systemd:
        name: postgresql-16
        state: started
        enabled: yes
      when: service_action == "start" # Pass via --extra-vars "service_action=start"

    - name: Stop PostgreSQL service
      ansible.builtin.systemd:
        name: postgresql-16
        state: stopped
      when: service_action == "stop"

    - name: Reload PostgreSQL service
      ansible.builtin.systemd:
        name: postgresql-16
        state: reloaded
      when: service_action == "reload"

- name: Perform PostgreSQL Backup
  hosts: postgresql
  become: yes

  tasks:
    - name: Include backup tasks if action is backup
      ansible.builtin.include_tasks: roles/postgresql_manage/tasks/backup.yml
      when: inventory_hostname == hostvars['node1']['inventory_hostname'] and action == "backup"

- name: Perform PostgreSQL Failover
  hosts: postgresql
  become: yes

  tasks:
    - name: Include failover tasks if action is failover
      ansible.builtin.include_tasks: roles/postgresql_manage/tasks/failover.yml
      when: inventory_hostname == hostvars['node1']['inventory_hostname'] and action == "failover"

Roles Details:
1. postgresql_install Role:
 * roles/postgresql_install/vars/main.yml:
   ---
pg_version: "16"
pg_data_dir: "/var/lib/pgsql/{{ pg_version }}/data"
pg_log_dir: "/var/lib/pgsql/{{ pg_version }}/logs"
pg_port: 5432
pg_replication_user: replicator
pg_replication_password: your_replication_password # CHANGE THIS!
pg_primary_ip: "{{ hostvars['node1']['ansible_host'] }}"
pg_replica_ip: "{{ hostvars['node2']['ansible_host'] }}"

 * roles/postgresql_install/tasks/main.yml (Common tasks for both primary and replica):
   ---
- name: Install PostgreSQL packages
  ansible.builtin.yum:
    name:
      - "postgresql{{ pg_version }}-server"
      - "postgresql{{ pg_version }}-contrib"
    state: present

- name: Initialize PostgreSQL database (if not already initialized)
  ansible.builtin.command: "/usr/pgsql-{{ pg_version }}/bin/postgresql-{{ pg_version }}-setup initdb"
  args:
    creates: "{{ pg_data_dir }}/PG_VERSION"

- name: Ensure PostgreSQL service is enabled
  ansible.builtin.systemd:
    name: "postgresql-{{ pg_version }}"
    enabled: yes

- name: Allow PostgreSQL port in firewall (if firewalld is active)
  ansible.posix.firewalld:
    port: "{{ pg_port }}/tcp"
    permanent: yes
    state: enabled
    immediate: yes
  when: ansible_facts.services["firewalld.service"] is defined and ansible_facts.services["firewalld.service"].state == "running"

- name: Configure primary node
  ansible.builtin.include_tasks: configure_primary.yml
  when: role == "primary"

- name: Configure replica node
  ansible.builtin.include_tasks: configure_replica.yml
  when: role == "replica"

 * roles/postgresql_install/tasks/configure_primary.yml:
   ---
- name: Generate PostgreSQL primary configuration (postgresql.conf)
  ansible.builtin.template:
    src: postgresql.conf.j2
    dest: "{{ pg_data_dir }}/postgresql.conf"
    owner: postgres
    group: postgres
    mode: '0600'
  notify: Restart PostgreSQL

- name: Generate PostgreSQL HBA configuration (pg_hba.conf) for primary
  ansible.builtin.template:
    src: pg_hba.conf.j2
    dest: "{{ pg_data_dir }}/pg_hba.conf"
    owner: postgres
    group: postgres
    mode: '0600'
  notify: Reload PostgreSQL

- name: Create replication user
  ansible.builtin.community.general.postgresql_user:
    name: "{{ pg_replication_user }}"
    password: "{{ pg_replication_password }}"
    priv: NOLOGIN
    role_attr_flags: "REPLICATION"
  become_user: postgres
  when: not pg_replication_user_exists.stat.exists # Only create if not exists
  register: pg_replication_user_creation

- name: Check if replication user exists
  ansible.builtin.stat:
    path: "{{ pg_data_dir }}/pg_ident.conf" # A dummy check, better to use postgresql_user module idempotency
  register: pg_replication_user_exists

- name: Restart PostgreSQL primary
  ansible.builtin.systemd:
    name: "postgresql-{{ pg_version }}"
    state: restarted

 * roles/postgresql_install/tasks/configure_replica.yml:
   ---
- name: Stop PostgreSQL service on replica before base backup
  ansible.builtin.systemd:
    name: "postgresql-{{ pg_version }}"
    state: stopped

- name: Remove existing data directory on replica for fresh base backup
  ansible.builtin.file:
    path: "{{ pg_data_dir }}"
    state: absent

- name: Take base backup from primary
  ansible.builtin.command: "pg_basebackup -h {{ pg_primary_ip }} -U {{ pg_replication_user }} -D {{ pg_data_dir }} -F p -Xs stream -P -R"
  become_user: postgres
  args:
    creates: "{{ pg_data_dir }}/postgresql.auto.conf" # Modern approach for replica config

- name: Ensure correct ownership and permissions for data directory
  ansible.builtin.file:
    path: "{{ pg_data_dir }}"
    owner: postgres
    group: postgres
    mode: '0700'
    recurse: yes

- name: Start PostgreSQL replica service
  ansible.builtin.systemd:
    name: "postgresql-{{ pg_version }}"
    state: started
    enabled: yes

 * roles/postgresql_install/templates/postgresql.conf.j2 (Simplified example, adjust as needed):
   listen_addresses = '*'
port = {{ pg_port }}
max_connections = 100
shared_buffers = 128MB
wal_level = replica # or hot_standby for older versions
archive_mode = on
archive_command = 'cp %p /var/lib/pgsql/{{ pg_version }}/archive/%f' # Example, consider dedicated WAL archiving
max_wal_senders = 10
wal_keep_size = 2048MB # Adjust based on your WAL generation
hot_standby = on # For replica to be readable

{% if role == "replica" %}
primary_conninfo = 'host={{ pg_primary_ip }} port={{ pg_port }} user={{ pg_replication_user }} password={{ pg_replication_password }}'
primary_slot_name = 'replica_slot' # Recommended for reliable replication
restore_command = 'cp /var/lib/pgsql/{{ pg_version }}/archive/%f %p' # For recovery from archive
{% endif %}

 * roles/postgresql_install/templates/pg_hba.conf.j2 (Simplified example, adjust for security):
   # TYPE  DATABASE        USER            ADDRESS                 METHOD

# "local" is for Unix domain socket connections only
local   all             all                                     trust
# IPv4 local connections:
host    all             all             127.0.0.1/32            scram-sha-256
# IPv6 local connections:
host    all             all             ::1/128                 scram-sha-256
# Allow replication connections from replica
host    replication     {{ pg_replication_user }} {{ pg_replica_ip }}/32  scram-sha-256

 * roles/postgresql_install/handlers/main.yml:
   ---
- name: Restart PostgreSQL
  ansible.builtin.systemd:
    name: "postgresql-{{ pg_version }}"
    state: restarted

- name: Reload PostgreSQL
  ansible.builtin.systemd:
    name: "postgresql-{{ pg_version }}"
    state: reloaded

2. postgresql_manage Role:
 * roles/postgresql_manage/tasks/backup.yml:
   ---
- name: Create backup directory if it doesn't exist
  ansible.builtin.file:
    path: "/var/lib/pgsql/{{ pg_version }}/backups"
    state: directory
    owner: postgres
    group: postgres
    mode: '0700'

- name: Take full PostgreSQL backup using pg_basebackup
  ansible.builtin.command: "pg_basebackup -h 127.0.0.1 -D /var/lib/pgsql/{{ pg_version }}/backups/full_backup_$(date +%Y%m%d%H%M%S) -F t -z -P -v"
  become_user: postgres
  args:
    creates: "/var/lib/pgsql/{{ pg_version }}/backups/full_backup_$(date +%Y%m%d%H%M%S)" # Simple check for idempotency

- name: Take logical backup of a specific database (example)
  ansible.builtin.command: "pg_dump -h 127.0.0.1 -U postgres your_database_name > /var/lib/pgsql/{{ pg_version }}/backups/your_database_name_$(date +%Y%m%d%H%M%S).sql"
  become_user: postgres
  args:
    creates: "/var/lib/pgsql/{{ pg_version }}/backups/your_database_name_$(date +%Y%m%d%H%M%S).sql" # Simple check for idempotency
  when: backup_type == "logical" # Pass via --extra-vars "backup_type=logical"

 * roles/postgresql_manage/tasks/failover.yml:
   ---
- name: Check if primary is running
  ansible.builtin.shell: "pg_isready -h {{ pg_primary_ip }} -p {{ pg_port }}"
  register: primary_status
  ignore_errors: true
  delegate_to: localhost # Run this check from the Ansible control node

- name: Stop primary if it's running (simulated failure or planned failover)
  ansible.builtin.systemd:
    name: "postgresql-{{ pg_version }}"
    state: stopped
  when: primary_status.rc == 0 and inventory_hostname == hostvars['node1']['inventory_hostname'] # Ensure we only run on primary

- name: Promote replica to primary
  ansible.builtin.command: "pg_ctl promote -D {{ pg_data_dir }}"
  become_user: postgres
  when: inventory_hostname == hostvars['node2']['inventory_hostname'] # Only run on replica
  register: promote_result

- name: Check promotion status
  ansible.builtin.debug:
    var: promote_result

- name: Wait for new primary to start
  ansible.builtin.wait_for:
    port: "{{ pg_port }}"
    host: "{{ hostvars['node2']['ansible_host'] }}"
    delay: 5
    timeout: 120
  when: inventory_hostname == hostvars['node2']['inventory_hostname']

How to Run:
 * Save the files: Create the directory structure and save the inventory.ini, playbook.yml, and the role files.
 * Replace placeholders:
   * your_ssh_user
   * your_primary_ip
   * your_replica_ip
   * your_replication_password (CRITICAL!)
   * your_database_name (for logical backup example)
 * Initial Installation and Configuration:
   ansible-playbook -i inventory.ini playbook.yml

   This will install PostgreSQL, configure the primary and replica, and set up replication.
 * Start/Stop/Reload Services:
   * To start all PostgreSQL services:
     ansible-playbook -i inventory.ini playbook.yml --tags "manage_services" --extra-vars "service_action=start"

   * To stop all PostgreSQL services:
     ansible-playbook -i inventory.ini playbook.yml --tags "manage_services" --extra-vars "service_action=stop"

   * To reload all PostgreSQL services:
     ansible-playbook -i inventory.ini playbook.yml --tags "manage_services" --extra-vars "service_action=reload"

   (Note: For specific node actions, you'd target roles/hosts more granularly or use --limit.)
 * Take Primary Backup:
   * To take a full pg_basebackup:
     ansible-playbook -i inventory.ini playbook.yml --tags "backup_primary" --extra-vars "action=backup"

   * To take a logical backup (e.g., pg_dump):
     ansible-playbook -i inventory.ini playbook.yml --tags "backup_primary" --extra-vars "action=backup backup_type=logical"

 * Stop Primary and Start Replica (Failover):
   ansible-playbook -i inventory.ini playbook.yml --tags "failover" --extra-vars "action=failover"

   This playbook currently assumes a manual trigger for failover. For a production environment, you'd integrate this with a monitoring system or a dedicated failover tool like Patroni or Repmgr.
Important Considerations and Improvements:
 * Security:
   * Passwords: Do NOT hardcode passwords in plain text. Use Ansible Vault for sensitive information.
   * pg_hba.conf: The provided pg_hba.conf is very permissive. Restrict access to only necessary IPs and users.
   * Firewall: Ensure firewalls are configured correctly to only allow necessary traffic.
 * Error Handling: Add more robust error handling and failed_when conditions.
 * Idempotency: Ensure all tasks are idempotent, meaning they can be run multiple times without causing unintended side effects.
 * WAL Archiving: Implement a proper WAL archiving strategy (e.g., to S3, NFS, or a dedicated WAL archive server) for point-in-time recovery and reliable replication. archive_command in postgresql.conf is crucial.
 * Replication Slots: Use replication slots (primary_slot_name) for more robust replication that prevents the primary from removing WAL segments needed by the replica.
 * Monitoring: Integrate with monitoring tools (Prometheus, Grafana, etc.) to track replication lag, primary/replica status, etc.
 * Automated Failover: For true high availability, consider using dedicated tools like:
   * Patroni: A highly advanced and recommended solution for PostgreSQL high availability.
   * Repmgr: Another popular tool for managing PostgreSQL replication and failover.
 * Testing: Thoroughly test your failover and backup procedures in a non-production environment.
 * PostgreSQL Version Specifics: Be aware that certain configurations and commands might differ slightly between PostgreSQL versions.
 * OS Differences: Adjust package names and service management commands if you're using Debian/Ubuntu or other Linux distributions.
 * Dedicated PostgreSQL User: Always perform PostgreSQL operations as the postgres user.
 * Logging: Configure comprehensive PostgreSQL logging to aid in troubleshooting.
 * Performance Tuning: The postgresql.conf parameters are basic. Tune them based on your workload and server resources.
This comprehensive guide should give you a solid foundation for managing PostgreSQL primary and replica nodes with Ansible. Remember to adapt it to your specific needs and security best practices!
