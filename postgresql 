Okay, this is a multi-part request.  I'll break it down into a comprehensive Ansible solution, covering installation, management, replication, and backups.  This will be quite a lengthy response, so let's dive in.

**Important Considerations Before You Start**

*   **User Permissions:**  Make sure the Ansible user has appropriate `sudo` privileges on the target nodes.  You'll likely need `become: true` in your tasks.
*   **Ansible Inventory:** This assumes you have an Ansible inventory file (`hosts`) defining your target servers.  You'll need to define groups like `postgresql_primary`, `postgresql_replica`, etc.
*   **Firewall:**  You'll need to ensure that firewalls are configured to allow traffic between the primary and replica servers on port 5432 (default PostgreSQL port) and, potentially, any SSH port you're using for replication setup.
*   **Security:**  Adjust database credentials (passwords) and connection settings to be secure and appropriate for your environment. **Never** hardcode passwords directly in the playbook. Use Ansible Vault or a secrets management solution.
*   **Error Handling:**  Consider adding error handling (e.g., `ignore_errors: true` with careful evaluation of results) to make your playbook more robust.
*   **Idempotency:** These playbooks are designed to be idempotent, meaning you can run them multiple times without unintended side effects.
*   **Target system:** These playbooks assume a Debian/Ubuntu-based system. The package names and module usage may vary on other Linux distributions like RHEL or CentOS.

**1. Project Structure**

A good project structure helps keep things organized:

```
postgresql_deploy/
├── ansible.cfg
├── hosts
├── group_vars/
│   ├── all.yml         # Default variables
│   └── postgresql.yml  # PostgreSQL specific variables
├── roles/
│   ├── postgresql_install/
│   │   ├── tasks/
│   │   │   └── main.yml
│   │   ├── handlers/
│   │   │   └── main.yml
│   │   └── templates/
│   │       └── postgresql.conf.j2  # Template for PostgreSQL config
│   ├── postgresql_manage/
│   │   └── tasks/
│   │       └── main.yml
│   ├── postgresql_replication/
│   │   ├── tasks/
│   │   │   └── main.yml
│   │   └── templates/
│   │       └── pg_hba.conf.j2
│   └── postgresql_backup/
│       └── tasks/
│           └── main.yml
└── site.yml          # Main playbook
```

**2. `ansible.cfg` (Optional - Configure Ansible)**

```ini
[defaults]
inventory = hosts
remote_user = your_ansible_user  # Replace
ask_become_pass = yes        # If needed
host_key_checking = False  # Disable SSH key checking for initial setup, remove later
```

**3. `hosts` (Inventory File)**

```ini
[postgresql_primary]
pg_primary ansible_host=your_primary_ip  # Replace with IP address

[postgresql_replica]
pg_replica ansible_host=your_replica_ip  # Replace with IP address

[postgresql:children]
postgresql_primary
postgresql_replica

[all:vars]
postgresql_version = 15 # Define the desired PostgreSQL version
```

**4. `group_vars/all.yml` (Global Variables)**

```yaml
# General variables applicable to all hosts
```

**5. `group_vars/postgresql.yml` (PostgreSQL Specific Variables)**

```yaml
postgresql_data_dir: "/var/lib/postgresql/{{ postgresql_version }}/main"
postgresql_listen_address: "*"  # Listen on all interfaces (adjust for security)
postgresql_port: 5432
postgresql_admin_user: postgres
postgresql_admin_password: "YourSuperSecretPassword"  # NEVER HARDCODE, USE ANSIBLE VAULT
replication_user: replicator
replication_password: "AnotherSuperSecretPassword" # NEVER HARDCODE, USE ANSIBLE VAULT
backup_dir: /var/backups/postgresql
backup_keep_days: 7
```

**6. Roles:**

**6.1 `roles/postgresql_install/tasks/main.yml`**

```yaml
---
- name: Add PostgreSQL APT repository
  become: true
  apt_repository:
    repo: "deb http://apt.postgresql.org/pub/repos/apt/ {{ ansible_distribution_release }}-pgdg main"
    state: present
    update_cache: yes
  when: ansible_os_family == "Debian"

- name: Import the repository key
  become: true
  apt_key:
    url: https://www.postgresql.org/media/keys/ACCC4CF8.asc
    state: present
  when: ansible_os_family == "Debian"

- name: Install PostgreSQL packages
  become: true
  apt:
    name:
      - postgresql-{{ postgresql_version }}
      - postgresql-client-{{ postgresql_version }}
      - postgresql-contrib-{{ postgresql_version }}
    state: present
    update_cache: yes

- name: Ensure PostgreSQL service is enabled and started
  become: true
  service:
    name: postgresql
    state: started
    enabled: yes

- name: Create admin user password if it doesn't exists
  become: true
  become_user: postgres
  postgresql_user:
    db: postgres
    name: "{{ postgresql_admin_user }}"
    password: "{{ postgresql_admin_password }}"
    priv: ALL
    role_attr_flags: SUPERUSER,CREATEROLE,CREATEDB
    state: present

- name: Template postgresql.conf
  become: true
  template:
    src: postgresql.conf.j2
    dest: "{{ postgresql_data_dir }}/postgresql.conf"
    owner: postgres
    group: postgres
    mode: 0644
  notify: restart postgresql
```

**6.2 `roles/postgresql_install/handlers/main.yml`**

```yaml
---
- name: restart postgresql
  become: true
  service:
    name: postgresql
    state: restarted
```

**6.3 `roles/postgresql_install/templates/postgresql.conf.j2`**

```jinja2
#------------------------------------------------------------------------------
# CONNECTIONS AND AUTHENTICATION
#------------------------------------------------------------------------------

listen_addresses = '{{ postgresql_listen_address }}'   # what IP address(es) to listen on;
port = {{ postgresql_port }}                # (change requires restart)
max_connections = 100                     # (change requires restart)
# shared_buffers = 128MB                  # min 128kB
#logging
log_destination = 'stderr'
logging_collector = on
log_directory = 'log'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
log_statement = 'none'
log_rotation_age = 1d
log_rotation_size = 10MB
```

**6.4 `roles/postgresql_manage/tasks/main.yml`**

```yaml
---
- name: Determine PostgreSQL service state
  become: true
  service:
    name: postgresql
    state: "{{ postgresql_action }}"
  vars:
    postgresql_action: "{{ lookup('vars', command) }}"

```

**6.5 `roles/postgresql_replication/tasks/main.yml`**

```yaml
---
- name: Create replication user on primary
  become: true
  become_user: postgres
  postgresql_user:
    db: postgres
    name: "{{ replication_user }}"
    password: "{{ replication_password }}"
    priv: REPLICATION
    role_attr_flags: REPLICATION
    state: present
  delegate_to: "{{ groups['postgresql_primary'][0] }}" # Execute on the primary server

- name: Template pg_hba.conf on primary
  become: true
  template:
    src: pg_hba.conf.j2
    dest: "{{ postgresql_data_dir }}/pg_hba.conf"
    owner: postgres
    group: postgres
    mode: 0600
  delegate_to: "{{ groups['postgresql_primary'][0] }}"
  notify: restart postgresql on primary

- name: Ensure PostgreSQL is stopped on replica
  become: true
  service:
    name: postgresql
    state: stopped
  delegate_to: "{{ groups['postgresql_replica'][0] }}"

- name: Delete existing data directory on replica
  become: true
  file:
    path: "{{ postgresql_data_dir }}"
    state: absent
  delegate_to: "{{ groups['postgresql_replica'][0] }}"

- name: Create the data directory on replica
  become: true
  file:
    path: "{{ postgresql_data_dir }}"
    state: directory
    owner: postgres
    group: postgres
  delegate_to: "{{ groups['postgresql_replica'][0] }}"

- name: Take a base backup on primary and restore on replica
  become: true
  become_user: postgres
  shell: |
    pg_basebackup -h "{{ groups['postgresql_primary'][0] }}" -U "{{ replication_user }}" -D "{{ postgresql_data_dir }}" -P -v -w
  delegate_to: "{{ groups['postgresql_replica'][0] }}"
  environment:
    PGPASSWORD: "{{ replication_password }}"

- name: Start PostgreSQL on replica
  become: true
  service:
    name: postgresql
    state: started
  delegate_to: "{{ groups['postgresql_replica'][0] }}"

- name: Create recovery.conf on replica
  become: true
  template:
    src: recovery.conf.j2
    dest: "{{ postgresql_data_dir }}/recovery.conf"
    owner: postgres
    group: postgres
    mode: 0600
  delegate_to: "{{ groups['postgresql_replica'][0] }}"
  notify: restart postgresql on replica
```

**6.6 `roles/postgresql_replication/templates/pg_hba.conf.j2`**

```jinja2
# IPv4 local connections:
host    all             all             127.0.0.1/32            trust

# IPv6 local connections:
host    all             all             ::1/128                 trust

# Allow replication connections from replica server
host    replication     {{ replication_user }}  {{ hostvars[groups['postgresql_replica'][0]].ansible_host }}/32  md5
```

**6.7 `roles/postgresql_replication/templates/recovery.conf.j2`**

```jinja2
standby_mode = 'on'
primary_conninfo = 'host={{ hostvars[groups['postgresql_primary'][0]].ansible_host }} port={{ postgresql_port }} user={{ replication_user }} password={{ replication_password }}'
trigger_file = '/tmp/trigger'
```

**6.8 `roles/postgresql_replication/handlers/main.yml`**

```yaml
---
- name: restart postgresql on primary
  become: true
  service:
    name: postgresql
    state: restarted
  delegate_to: "{{ groups['postgresql_primary'][0] }}"

- name: restart postgresql on replica
  become: true
  service:
    name: postgresql
    state: restarted
  delegate_to: "{{ groups['postgresql_replica'][0] }}"
```

**6.9 `roles/postgresql_backup/tasks/main.yml`**

```yaml
---
- name: Ensure backup directory exists
  become: true
  file:
    path: "{{ backup_dir }}"
    state: directory
    owner: postgres
    group: postgres
    mode: 0755

- name: Create backup script
  become: true
  template:
    src: backup_script.j2
    dest: /usr/local/bin/backup_postgresql.sh
    owner: root
    group: root
    mode: 0755

- name: Create cron job
  become: true
  cron:
    name: "PostgreSQL Backup"
    job: "/usr/local/bin/backup_postgresql.sh"
    user: postgres
    minute: "0"
    hour: "3"  # Run at 3 AM
```

**6.10 `roles/postgresql_backup/templates/backup_script.j2`**

```jinja2
#!/bin/bash

DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR="{{ backup_dir }}"
DB_NAME=all
PGPASSWORD="{{ postgresql_admin_password }}" # NEVER HARDCODE IN REAL LIFE
DAYS_TO_KEEP="{{ backup_keep_days }}"

mkdir -p "$BACKUP_DIR/$DATE"

pg_dumpall -U "{{ postgresql_admin_user }}" | gzip > "$BACKUP_DIR/$DATE/all_databases_$DATE.sql.gz"

find "$BACKUP_DIR" -type d -mtime +"$DAYS_TO_KEEP" -exec rm -rf {} \;
```

**7. `site.yml` (Main Playbook)**

```yaml
---
- hosts: postgresql
  become: true
  roles:
    - postgresql_install

- hosts: postgresql_replica
  become: true
  roles:
    - postgresql_replication

- hosts: postgresql_primary
  become: true
  roles:
    - postgresql_backup

- hosts: postgresql
  become: true
  roles:
    - postgresql_manage
  vars:
    command: "{{ action | default('start') }}"
  tasks:
    - name: Execute command
      debug:
        msg: "Executed command"
```

**How to Use**

1.  **Setup:** Populate your `hosts` file, fill in the variables in `group_vars/` (especially the PostgreSQL specific ones), and ideally use Ansible Vault to encrypt your passwords.

2.  **Run:**

    *   **Install & Configure:** `ansible-playbook site.yml`
    *   **Start PostgreSQL:** `ansible-playbook site.yml -e "action=start"`
    *   **Stop PostgreSQL:** `ansible-playbook site.yml -e "action=stop"`
    *   **Reload PostgreSQL:** `ansible-playbook site.yml -e "action=reload"`
    *   **Backup:**  The backup cron job will run automatically based on the settings in `roles/postgresql_backup`.

**Important Notes and Improvements**

*   **Ansible Vault:**  **Crucially**, use Ansible Vault to encrypt the `postgresql_admin_password` and `replication_password` in `group_vars/postgresql.yml`.  Otherwise, you're committing sensitive information to your repository in plaintext.
*   **Security Hardening:**  This is a basic example.  In a production environment, you'll want to harden PostgreSQL security further (e.g., configure stricter firewall rules, restrict listen addresses, use client certificates).
*   **Monitoring:** Integrate with a monitoring system (e.g., Prometheus, Nagios) to track the health and performance of your PostgreSQL instances.
*   **Failover:**  This replication setup provides a basic warm standby.  For automatic failover, you'll need to use a solution like Patroni, Pacemaker, or repmgr.  These solutions provide automatic promotion of the replica to primary in case of primary failure.
*   **Backup Verification:**  Implement a process to verify that your backups are valid and restorable.
*   **Testing:** Use Molecule or similar testing frameworks to automatically test your Ansible roles and playbooks.
*   **Error Handling:** Add `rescue` blocks to your tasks to handle errors gracefully.  For example, you might want to rollback changes if a task fails.
*   **Variables:** Consider making more aspects configurable via variables (e.g., the backup schedule, log rotation settings, etc.).

This is a comprehensive starting point. You'll need to adapt it to your specific requirements and environment. Remember to prioritize security and thoroughly test your configuration before deploying it to production. Good luck!